import copy
import time

import numpy as np

NO_POSITION = 0
LONG_OPEN = 1
SHORT_OPEN = 2


class Backtester:
    def __init__(self, strategy, pyramiding=1, stake_percent=0.2, initial_capital=1, leverage=5, commission=0.00075):
        """ Strategies have both data and indicators.
            The backtester iterates through the data as generated by the strategy
            and calculates metrics over time.
            The backtester assumes that the data is accurate and any indicators
            have been calculated correctly (i.e. not using future data).
            The idea is that each time the backtester iterates through a new row of data,
            that is equivalent to a new row of kline data being received by the bot,
            indicators updated and decisions made on it.
        """

        self.exchange = MockExchange(initial_capital=initial_capital, leverage=leverage, commission=commission)

        self.strategy = strategy
        self.initial_capital = initial_capital
        self.total_equity = initial_capital
        self.exchange_commission = commission
        self.leverage = leverage
        self.max_pyramid = pyramiding
        self.stake_percent = stake_percent
        self.n_trades = 0
        self.total_realised_pl = 0
        self.state = NO_POSITION
        self.current_position = None
        self.pyramid_size = 0

        self.run_backtest()

    def get_total_realised_pl(self):
        return self.total_realised_pl

    def _get_downside_deviation(self, trades):
        sum = 0
        for x in trades:
            if x.realised_pl < 0:
                sum += (x.realised_pl) * (x.realised_pl)
        
        dd = np.sqrt(sum/len(trades))
        if dd == 0.0:
            return 1
        return np.sqrt(sum/len(trades)) * 100

    def get_sharpe_ratio(self):
        rf = 0.001
        trades = self.exchange.analyse_history()
        if len(trades) == 0:
            return -1
        avg_return_percent = np.mean([(x.realised_pl/x.margin) for x in trades])
        dd = self._get_downside_deviation(trades)
        return min((avg_return_percent - rf) / dd, 1.5)


    def print_report(self):
        print(f"Backtesting report:")
        n_profitable = 0
        sum_profitable = 0.0
        n_losers = 0
        sum_losers = 0.0
        for x in self.exchange.analyse_history():
            if x.realised_pl > 0:
                n_profitable += 1
                sum_profitable += x.realised_pl
            else:
                n_losers += 1
                sum_losers += abs(x.realised_pl)
            print(x)

        n_losers = max(n_losers, 1)
        sum_losers = max(sum_losers, 1)
        self.n_trades = max(self.n_trades, 1)

        perc_prof = n_profitable / self.n_trades
        prof_factor = sum_profitable / sum_losers

        print()
        print(f"    # trades: {self.n_trades}")
        print(f"    total realised pl: {self.total_realised_pl}")
        print(f"    total equity: {self.total_equity}")
        print()
        print(f"    percetage profitable: {perc_prof}")
        print(f"    profit factor: {prof_factor}")



    def _get_order_size(self, size_btc, cur_price):
        """ Given the amount of BTC you want to stake, returns the amount of contracts to buy
            at the current price, such that the given BTC amount (including fees) is used as margin
        """
        initial_margin = self.stake_percent * self.total_equity
        contract_qty = initial_margin * cur_price * self.leverage
        fee = (contract_qty / cur_price) * 0.00075
        return initial_margin, contract_qty, fee

    def run_backtest(self):
        # print('running backtest')

        self.state = NO_POSITION
        last_close = 0    
        for index, row in self.strategy.df.iterrows():
            margin, order_size, fee = self._get_order_size(self.stake_percent * self.total_equity, row['close'])
            if row['long'] == 1:
                self._long(row['close'], margin, order_size, fee)
                
            elif row['short'] == 1:
                self._short(row['close'], margin, order_size, fee)
                
            elif (row['exitshort'] == 1) or (row['exitlong'] == 1):
                self._exit_position(row['close'])
            last_close = row['close']
        
        if (self.exchange.position != None):
            self._exit_position(last_close) # TODO unhardcode this

        # print('backtest complete')
        # print('total positions: ' + str(self.n_trades))
        # print('total pl: ' + str(self.total_realised_pl))
        # print()


    def _long(self, cur_price, margin, contracts, fee):
        if self.state == NO_POSITION:
            # open new long position
            self.exchange.open_position(long=True, margin=margin, contracts=contracts, cur_price=cur_price)
            self.pyramid_size = 1
            self.state = LONG_OPEN
            self.total_equity -= (margin + fee)
        elif self.state == LONG_OPEN:
            # pyramid new long position if max pyramid isn't already reached
            if self.pyramid_size < self.max_pyramid:
                self.exchange.increase_posn(margin=margin, contracts=contracts, entry_price=cur_price)
                self.total_equity -= (margin + fee)
                self.pyramid_size += 1
            # else do nothing
        elif self.state == SHORT_OPEN:
            # close open long and open a short
            self._exit_position(cur_price)
            self.exchange.open_position(long=True, margin=margin, contracts=contracts, cur_price=cur_price)
            self.pyramid_size = 1
            self.state = LONG_OPEN
            self.total_equity -= (margin + fee)

    def _short(self, cur_price, margin, contracts, fee):
        if self.state == NO_POSITION:
            # open new long position
            self.exchange.open_position(long=False, margin=margin, contracts=contracts, cur_price=cur_price)
            self.pyramid_size = 1
            self.state = SHORT_OPEN
            self.total_equity -= (margin + fee)
        elif self.state == SHORT_OPEN:
            # pyramid new long position if max pyramid isn't already reached
            if self.pyramid_size < self.max_pyramid:
                self.exchange.increase_posn(margin=margin, contracts=contracts, entry_price=cur_price)
                self.total_equity -= (margin + fee)
                self.pyramid_size += 1
            # else do nothing
        elif self.state == LONG_OPEN:
            # close open long and open a short
            self._exit_position(cur_price)
            self.exchange.open_position(long=False, margin=margin, contracts=contracts, cur_price=cur_price)
            self.pyramid_size = 1
            self.state = SHORT_OPEN
            self.total_equity -= (margin + fee)

    def _exit_position(self, cur_price):
        if self.state != NO_POSITION:
            original_margin, realised_pl, fee = self.exchange.close_position(cur_price)
            self.total_realised_pl += realised_pl
            self.n_trades += 1
            self.state = NO_POSITION
            self.pyramid_size = 0
            self.current_position = None
            self.total_equity += (original_margin + realised_pl) - fee
            


class MockExchange:
    def __init__(self, initial_capital=1, leverage=5, commission=0.00075):
        self.capital = initial_capital
        self.leverage = leverage
        self.commission = commission
        self.position = None
        self.trading_history = []

    def open_position(self, long=True, margin=0.2, contracts=100, cur_price=0):
        self.position = Position(long, margin, contracts, cur_price, self.leverage)

    def increase_posn(self, margin, contracts, entry_price):
        self.position.increase_posn(margin=margin, contracts=contracts, entry_price=entry_price)

    def close_position(self, cur_price):
        self.init_margin, self.realised_pl, self.fee = self.position.close(cur_price)
        self.trading_history.append(self.position)
        self.position = None
        return self.init_margin, self.realised_pl, self.fee

    def analyse_history(self):
        # look at trading history and generate some metrics            
        return self.trading_history




class Position:
    def __init__(self, long=True, margin=0.2, contracts=100, start_price=0.0, leverage=5):
        self.long = long
        self.contracts = contracts
        self.average_entry_price = start_price
        self.leverage = leverage
        self.margin = margin
        self.contract_value_in_currency = (self.contracts / start_price)

    def increase_posn(self, margin=0.2, contracts=100, entry_price=0.0):
        self.contracts += contracts
        self.margin += margin
        self.contract_value_in_currency += (contracts / entry_price)
        self.average_entry_price = self.contracts / self.contract_value_in_currency

    def close(self, end_price=1):
        """ Return the realised P&L of this position, minus fees
        """
        self.end_price = end_price
        self.closing_fee = (self.contracts / end_price) * (0.00075)

        if self.long:
            self.realised_pl = self.contracts * (1 / self.average_entry_price - 1 / self.end_price)
            return self.margin, self.realised_pl, self.closing_fee
        else: #!self.long
            self.realised_pl = self.contracts * (1 / self.end_price - 1 / self.average_entry_price)
            return self.margin, self.realised_pl, self.closing_fee

    def get_unrealised_pl(self, cur_price):
        if self.long:
            return self.contracts * (1 / self.average_entry_price - 1 / cur_price)
        else: #!self.long
            return self.contracts * (1 / cur_price - 1 / self.average_entry_price)

    # TODO: Work out if an order has been liquidated/hit its stop loss/hit its take profit

    def __str__(self):
        return f"posn:\n\tlong={self.long}\n\tsize={self.contracts}\n\tinit_margin={self.margin}\n\tavg_entry_price={self.average_entry_price}\n\tclose_price={self.end_price}\n\trealised_pl={self.realised_pl}\n\tfee={self.closing_fee}"

