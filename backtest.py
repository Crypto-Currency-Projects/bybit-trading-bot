import copy
import time

import numpy as np

from exchange.mock_exchange import MockExchange

NO_POSITION = 0
LONG_OPEN = 1
SHORT_OPEN = 2

class Backtester:
    def __init__(self, strategy, pyramiding=1, stake_percent=0.2, initial_capital=1, leverage=5, commission=0.00075):
        """ Strategies have both data and indicators.
            The backtester iterates through the data as generated by the strategy
            and calculates metrics over time.
            The backtester assumes that the data is accurate and any indicators
            have been calculated correctly (i.e. not using future data).
            The idea is that each time the backtester iterates through a new row of data,
            that is equivalent to a new row of kline data being received by the bot,
            indicators updated and decisions made on it.
        """

        self.exchange = MockExchange(initial_capital=initial_capital, leverage=leverage, commission=commission)

        self.strategy = strategy
        self.initial_capital = initial_capital
        self.total_equity = initial_capital
        self.exchange_commission = commission
        self.leverage = leverage
        self.max_pyramid = pyramiding
        self.stake_percent = stake_percent
        self.n_trades = 0
        self.total_realised_pl = 0
        self.state = NO_POSITION
        self.current_position = None
        self.pyramid_size = 0

        self.run_backtest()

    def get_total_realised_pl(self):
        return self.total_realised_pl

    def _get_downside_deviation(self, trades):
        sum = 0
        for x in trades:
            if x.realised_pl < 0:
                sum += (x.realised_pl) * (x.realised_pl)
        
        dd = np.sqrt(sum/len(trades))
        if dd == 0.0:
            return 1
        return np.sqrt(sum/len(trades)) * 100

    def get_sharpe_ratio(self):
        rf = 0.001
        trades = self.exchange.analyse_history()
        if len(trades) == 0:
            return -1
        avg_return_percent = np.mean([(x.realised_pl/x.margin) for x in trades])
        dd = self._get_downside_deviation(trades)
        return min((avg_return_percent - rf) / dd, 1.5)

    def print_report(self):
        print(f"Backtesting report:")
        n_profitable = 0
        sum_profitable = 0.0
        n_losers = 0
        sum_losers = 0.0
        for x in self.exchange.analyse_history():
            if x.realised_pl > 0:
                n_profitable += 1
                sum_profitable += x.realised_pl
            else:
                n_losers += 1
                sum_losers += abs(x.realised_pl)
            print(x)

        n_losers = max(n_losers, 1)
        sum_losers = max(sum_losers, 1)
        self.n_trades = max(self.n_trades, 1)

        perc_prof = n_profitable / self.n_trades
        prof_factor = sum_profitable / sum_losers

        print()
        print(f"    # trades: {self.n_trades}")
        print(f"    total realised pl: {self.total_realised_pl}")
        print(f"    total equity: {self.total_equity}")
        print()
        print(f"    percetage profitable: {perc_prof}")
        print(f"    profit factor: {prof_factor}")

    def _get_order_size(self, size_btc, cur_price):
        """ Given the amount of BTC you want to stake, returns the amount of contracts to buy
            at the current price, such that the given BTC amount (including fees) is used as margin
        """
        initial_margin = self.stake_percent * self.total_equity
        contract_qty = initial_margin * cur_price * self.leverage
        fee = (contract_qty / cur_price) * 0.00075
        return initial_margin, contract_qty, fee

    def run_backtest(self):
        # print('running backtest')

        self.state = NO_POSITION
        last_close = 0    
        for index, row in self.strategy.df.iterrows():
            margin, order_size, fee = self._get_order_size(self.stake_percent * self.total_equity, row['close'])
            if row['long'] == 1:
                self._long(row['close'], margin, order_size, fee)
                
            elif row['short'] == 1:
                self._short(row['close'], margin, order_size, fee)
                
            elif (row['exitshort'] == 1) or (row['exitlong'] == 1):
                self._exit_position(row['close'])
            last_close = row['close']
        
        if (self.exchange.position != None):
            self._exit_position(last_close) # TODO unhardcode this

    def _long(self, cur_price, margin, contracts, fee):
        if self.state == NO_POSITION:
            # open new long position
            self.exchange.open_position(long=True, margin=margin, contracts=contracts, cur_price=cur_price)
            self.pyramid_size = 1
            self.state = LONG_OPEN
            self.total_equity -= (margin + fee)
        elif self.state == LONG_OPEN:
            # pyramid new long position if max pyramid isn't already reached
            if self.pyramid_size < self.max_pyramid:
                self.exchange.increase_posn(margin=margin, contracts=contracts, entry_price=cur_price)
                self.total_equity -= (margin + fee)
                self.pyramid_size += 1
            # else do nothing
        elif self.state == SHORT_OPEN:
            # close open long and open a short
            self._exit_position(cur_price)
            self.exchange.open_position(long=True, margin=margin, contracts=contracts, cur_price=cur_price)
            self.pyramid_size = 1
            self.state = LONG_OPEN
            self.total_equity -= (margin + fee)

    def _short(self, cur_price, margin, contracts, fee):
        if self.state == NO_POSITION:
            # open new long position
            self.exchange.open_position(long=False, margin=margin, contracts=contracts, cur_price=cur_price)
            self.pyramid_size = 1
            self.state = SHORT_OPEN
            self.total_equity -= (margin + fee)
        elif self.state == SHORT_OPEN:
            # pyramid new long position if max pyramid isn't already reached
            if self.pyramid_size < self.max_pyramid:
                self.exchange.increase_posn(margin=margin, contracts=contracts, entry_price=cur_price)
                self.total_equity -= (margin + fee)
                self.pyramid_size += 1
            # else do nothing
        elif self.state == LONG_OPEN:
            # close open long and open a short
            self._exit_position(cur_price)
            self.exchange.open_position(long=False, margin=margin, contracts=contracts, cur_price=cur_price)
            self.pyramid_size = 1
            self.state = SHORT_OPEN
            self.total_equity -= (margin + fee)

    def _exit_position(self, cur_price):
        if self.state != NO_POSITION:
            original_margin, realised_pl, fee = self.exchange.close_position(cur_price)
            self.total_realised_pl += realised_pl
            self.n_trades += 1
            self.state = NO_POSITION
            self.pyramid_size = 0
            self.current_position = None
            self.total_equity += (original_margin + realised_pl) - fee
